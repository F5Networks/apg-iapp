#TMSH-VERSION: 12.1.0

    cli admin-partitions {
    	update-partition Common
    }
    sys application template /Common/F5.safe {
    	actions {
    		definition {
    			html-help {
<p><b>SAFE iApp Template</b></p>
<p>This template creates a complete configuration optimized for the SED application</p>
<ul>
  <li>Before you can configure the BIG-IP to work with SED application, ensure that the SED cluster up and running.</li>
  <li>For a complete walkthrough of this iApp, as well as detailed information and help, see <b>https://github.com/F5Networks/shape-iapp/blob/safe-v1.0.0/SAFE/Deploy%20SAFE%20iApp%20Template%20in%20BIG-IP%2C%20v1.0.0.pdf</b></li>
</ul>


<p>
<h6>General</h6>
<ul> 
    <li><b>Clean Before Deletion:</b> Set to Yes to permanently delete the iApp. To complete deletion, click Finished and then delete the iApp from the iApp list at iApps>Application Services>Applications.</li>
    <li><b>Activate Kill-Switch:</b> Set to Yes to disable, but not permanently delete the iApp. When the iApp is disabled, HTTP requests are sent to the web application’s server directly without any intervention from Shape.</li>
</ul>

<h6>JavaScript Injection Configuration</h6>
<ul>
    <li><b>BIG-IP Handles JS Injections:</b> Choose whether you want the BIG-IP to inject script tags or you want to do it manually.</li>
    <li><b>Shape JS URL or Path:</b> Enter the path you received from F5 support for the Shape JS injection.</li>
    <li><b>Location for Shape JS Injection:</b> From the drop-down list, select a location in the HTML code of your webpage for the Shape JS Injection.</li>
    <li><b>Script Attribute:</b> Choose your preferred attribute for the script. Async, Sync or Defer.</li>
    <li><b>Inject Shape JS in Specific Webpages Only:</b> Select Yes if you want to inject the Shape JS in specific webpages of your web application. Select No to inject the Shape JS in all webpages of your web application.</li>
    <li><b>JS Injection Paths:</b> If you set Inject Shape JS in specific webpages only = Yes, enter here the paths of the webpages in your application to receive the Shape JS injections.</li>
    <li><b>Exclude Shape JS Injection from Specific Webpages:</b> Select Yes if you want to exclude the Shape JS from specific webpages in your web application.</li>
    <li><b>JS Excluded Paths:</b> If you set Exclude Shape JS injection from specific webpages = Yes, enter here the paths of the webpages in your application where the Shape JS injections should be excluded.</li>
    <li><b>Additional JS API Endpoints:</b> Add additional endpoints for the API to support.</li>
</ul>
<h6>Cookie Decryption and Processing</h6>
<ul>
    <li><b>Endpoints:</b> Enter here the paths to the web pages on which you want to decrypt and process cookies. Note: paths are not case sensitive (all letters are set to lower case) and must start with ‘/’.</li>
    <li><b>Cookie Name:</b> Enter the cookie name you received from F5 support for the fraud recommendation cookie.</li>
    <li><b>Encryption Key:</b> Enter the encryption key you received from F5 support for the fraud recommendation cookie. The key has to be base64 encoded.</li>
    <li><b>Header Name to Add:</b> Enter the header name you received from F5 support for the fraud recommendation header.</li>
</ul>
<h6>Pool Configuration</h6>
<ul>
    <li><b>Traffic Routing Methodology:</b> Select whether you want the iApp pool to be routed according to the Active/Active method or the Active/Passive method.</li>
    <li><b>Cookie Persistence for Shape Protection Pool:</b> Select Enable if, after initial load‑balancing, you want HTTP requests of the same session always sent to the same pool member in the Shape Protection Pool. Select Disable if you want the BIG-IP to perform standard load balancing.</li>
    <li><b>Shape Protection Pool:</b> Add here the IP or FQDN for every pool member of the SAFE cluster. If you chose the Active/Passive routing method, you also need to assign a priority group number for the pool member, where a lower number means higher priority. </li>
    <li><b>Add HTTP Health Check:</b> Choose whether to perform the HTTP Health Check on the entire pool. The HTTP Health Check is performed in intervals of 5 seconds.</li>
</ul>
<h6>Virtual Server Configuration</h6>
<ul>
    <li><b>Application’s Virtual Server(s) to Protect:</b> Select your web application's virtual server(s). Selecting at least one virtual server is mandatory.</li>
</ul>
<h6>Advanced Features Configuration</h6>
<ul>
    <li><b>Rewrite XFF Header with Connecting IP:</b> Select Yes to add an XFF header to requests.</li>
    <li><b>Add Server-Side SSL Profile for Shape Pool:</b> If you want to use an SSL profile that is different from what the application pool uses, select it here.</li>
    <li><b>Encrypting Virtual Server IP:</b> A default IP is assigned. If you have a virtual server already configured to this IP, assign a different IP here.</li>
    <li><b>Server Name:</b> The Server Name Indication (SNI) for pool members. </li>
    <li><b>Enable Debug:</b> Select Yes to enable debug logs. </li>
</ul>
</p>




}
    			implementation {
tmsh::log_dest file
tmsh::log_level crit
tmsh::include "f5.app_utils"

puts "======================== $tmsh::app_name LOG ============================="
#********************* Global Variables ***********************
set ::iapp_name "/Common/$tmsh::app_name"
set ::sse_irule_name "$::iapp_name\_Shape_iRule"
set ::html_js_rule_name "$::iapp_name\_ShapeJSRule"
set ::html_iojs_rule_name "$::iapp_name\_ShapeIOJSRule"
set ::shape_inject_html_profile_name "$::iapp_name\_ShapeJsHtml"
set ::iapp_oneconnect "$::iapp_name\_oneconnect"
set ::html_before_script_rule "$::iapp_name\_prepened_script"
set ::persist_cookie_name "$::iapp_name\_persist_cookie"
set ::sni_profile_name "$::iapp_name\_serverssl"

# html tag match irule event. This section will insert to the iRule if needed.
set ::html_tag_matched_irule {
# This event is relevant only when js injection required location is before script tag.
when HTML_TAG_MATCHED {
    if { ![info exists is_js_injected] } {
        if { $shape_debug }{log local0. "prepend JS before [HTML::tag name] tag"}
        HTML::tag prepend __SNIPPET__
        set is_js_injected 1
    }
}
}

######################################
########SHAPE SSE iRule Start ########
set ::shape_sed_irule	{
proc base64url_decode { var_b64_url } {
  set var_b64 "[string map [list - + _ \/ ] $var_b64_url]"
  if { [string length $var_b64] % 4 != 0 } {
      append var_b64 [string repeat = [expr {4 - [string length $var_b64] % 4}]]
  }
  return [b64decode $var_b64]
}

when RULE_INIT {
  set b64_key "__ENC_KEY__"
  set ::key 0
  if {$b64_key != 0} {
    set ::key [b64decode $b64_key]
  }
}

# Set the lowest priority to not disturb the Customer iRules
priority 1000

proc route_shape_traffic {use_different_ssl shape_pool shape_debug} {
     # This variable used when customer choose to use different ssl for shape pools
    set shape_ssl_vs_name  __SHAPE_SSL_VS_NAME__
    if { $use_different_ssl } {
        persist none
        # In case a different ssl is required for SSE pool, disable SSL on serverside to pass data to the encrypting VS
        __DISABLE_SSL__
        virtual $shape_ssl_vs_name
        if { $shape_debug }{ log local0. "successfully routed to $shape_ssl_vs_name" }
    } else {
        __SHAPE_COOKIE_PERSIST__
        pool $shape_pool
    }
}

proc route_to_application {pool} {
    pool ${pool}
}

proc request_js {use_different_ssl shape_pool kill_switch http_path shape_debug} {
    # If request is for Shape JS or telemetry request, route it to Shape
    if { $shape_debug }{ log local0. "[IP::client_addr]:[TCP::client_port]: Got JS request: ${http_path}" }

    # Test if the pool has active members before sending traffic
    if  { [active_members ${shape_pool}] >= 1 && $kill_switch == 0 } {
        snat automap
        call route_shape_traffic $use_different_ssl ${shape_pool} $shape_debug
        return 0
    } else {
        # If the ShapeShifter pool is not available, then no need to forward this to origin, send back an empty 200 OK
        # Can also put an empty file at Origin for the Shape js request for occasions when the iRule is disabled.
        if { $shape_debug }{ log local0. "[IP::client_addr]:[TCP::client_port]: ShapeJS URI, but ${shape_pool} pool is down or Kill Switch is active!!! Sent HTTP 200 response"}
        HTTP::respond 200 noserver Cache-Control "no-cache"
        return 1
    }
}

proc should_send_to_sse {anyurl posturl geturl puturl http_path} {
    set anyurl_names ""
    set posturl_names ""
    set geturl_names ""
    set puturl_names ""

    if {[class exists ${anyurl}]} { set anyurl_names [class names ${anyurl}] }
    if {[class exists ${posturl}]} { set posturl_names [class names ${posturl}] }
    if {[class exists ${geturl}]} { set geturl_names [class names ${geturl}] }
    if {[class exists ${puturl}]} { set puturl_names [class names ${puturl}] }

    #ANY
    foreach {endpoint} $anyurl_names {
        if {${http_path} matches_glob $endpoint} {
            return true
        }
    }

    if { [HTTP::method] eq "POST" } {
        foreach {endpoint} $posturl_names {
            if {${http_path} matches_glob $endpoint} {
                return true
            }
        }
    }
    if { [HTTP::method] eq "GET" } {
        foreach {endpoint} $geturl_names {
            if {${http_path} matches_glob $endpoint} {
                return true
            }
        }
    }
    if { [HTTP::method] eq "PUT" } {
        foreach {endpoint} $puturl_names {
            if {${http_path} matches_glob $endpoint} {
                return true
            }
        }
    }
    if { [HTTP::method] eq "OPTIONS" } {
        lappend dg_list $posturl_names $geturl_names $puturl_names
        foreach {endpoint} $dg_list {
            if {${http_path} matches_glob $endpoint} {
                return true
            }
        }
    }
    return false
}

when SERVER_CONNECTED {
    # Disable SSL serverside profile for SSL offload use cases
    if {[LB::server port] == 80 } {
        __DISABLE_SSL__
    }
}

when CLIENT_ACCEPTED {
    set cookie_name "__COOKIE_NAME__"
    set alg "aes-128-cbc"
    set fr_header "__FR_HEADER__"
    set safe_endpoints __SAFE_EP_DG__
    set safe_domain "__SAFE_DOMAIN__"
    # Log debug messages (1=yes, 0=no)
    # Set to 0 when not debugging this iRule
    set shape_debug __DEBUG__

    #Datagroup names per HTTP Method
    set geturl __GET_EP_DG__
    set posturl __POST_EP_DG__
    set puturl __PUT_EP_DG__
    set anyurl __ANY_EP_DG__
    set JS_DG __JS_DG__
    # Entry points that should be injected with JS
    set included_entry_points __INCLUDED_ENTRY_POINTS_DG__
    # Inject JS to specific path
    set inject_specific_path __JS_SPECIFIC_PATH__
    # Entry points that should be excluded from JS injection
    set excluded_entry_points __EXCLUDED_ENTRY_POINTS_DG__
    # Exclude JS Injection from specific paths
    set inject_exclude_path __JS_EXCLUDED_PATH__
    # Set 'Rewrite XFF header with Connecting IP' variable
    set rewrite_xff __XFF__

    # Set 'Add different server SSL profile for Shape pool' variable
    # If true then we split traffic into 2 different VS (client<->bip<->ws, bip<->sse)
    set use_different_ssl __USE_DIFFERENT_SSL__
    # SSE pool for JS routing
    set shape_pool __SHAPE_SSE_POOL__
    # Kill switch/bypass of Shape API (1=yes, 0=no)
    set kill_switch __KILL_SWITCH__
}

when HTTP_REQUEST {

    # bypass the injection if needed (HTML::disable)
    set bypass 0

    # Remove trailing '/' from HTTP::path (if no trailing slash, nothing will happened)
    set http_path [string tolower [HTTP::path -normalized]]
    if { not ( ${http_path} equals "/" ) } { set http_path [string trimright ${http_path} "/"] }
    # JavaScript path
    set js_path __JS_PATH__
    
    #Save the name of virtual's default pool
    set app_pool [LB::server pool]
    __APP_PERSIST_NONE__
    if { $kill_switch } {
        if { $shape_debug }{ log local0. "Kill switch activated, suspending processing."}
        HTML::disable
        return
    }

    # Disable the HTML if injection configured to specific pages
    if { $inject_specific_path } {
        HTML::disable
        foreach {endpoint} [class names $included_entry_points] {
            if { ${http_path} matches_glob $endpoint } {
                HTML::enable
            }
        }
    }
    if { $inject_exclude_path } {
        foreach {endpoint} [class names $excluded_entry_points] {
            if { ${http_path} matches_glob $endpoint } {
              HTML::disable
            }
        }
    }

    if { [class match [string tolower $js_path] starts_with __API_JS_DG__] || ( [HTTP::method] eq "GET" && [class match [string tolower $js_path] equals $JS_DG]) } {
        set bypass 1
        # If request is for Shape JS or JS API call, route it to Shape and get out
        HTTP::host $safe_domain
        if { [call request_js $use_different_ssl $shape_pool $kill_switch ${http_path} $shape_debug] } {
            return
        }
    } else {
        if { [HTTP::header exists $fr_header] } {
            if { $shape_debug } { log local0. "WARNING: Found $fr_header! removing" }
            HTTP::header remove $fr_header
        }
        if { [HTTP::cookie exists $cookie_name]} {
            if { $::key != 0 } {
                foreach {endpoint} [class names $safe_endpoints] {
                    if {${http_path} matches_glob $endpoint} {
                        catch {
                            set cookie_value [URI::decode [HTTP::cookie value $cookie_name]]
                            set cookie_value [lindex [regexp -inline {\\"fr\\":\\"(.*?)\\"} $cookie_value] 1]
                            set iv [call base64url_decode [substr $cookie_value 0 24]]
                            set enc_data [call base64url_decode [substr $cookie_value 24]]
                            # If customer entered wrong encryption key, we won't be able to decrypt the cookie so we won't process it
                            set dec_fr_value [CRYPTO::decrypt -alg $alg -key $::key -iv $iv $enc_data]
                            if { $shape_debug } { log local0. "$cookie_name decrypted content: $dec_fr_value" }
                            HTTP::header insert $fr_header $dec_fr_value
                        } error
                        if { $error != "" && $shape_debug } {
                            log local0. "Could not decrypt fr cookie: $error"
                        }
                        break
                    }
                }
            }
            HTTP::cookie remove $cookie_name
        }
    }

    
    

    # Insert XFF header
    if { $rewrite_xff && !$bypass } {
        HTTP::header insert X-Forwarded-For [IP::client_addr]
    }
}

when HTTP_RESPONSE {

    # Clear the injected JS flag for each response.
    if {[info exists is_js_injected]} {
        unset is_js_injected
    }

    # Do not inject javascript for Shape interstitials
    if { ([info exists bypass] && $bypass)} {
        HTML::disable
    }
}

}
######## SHAPE SSE iRule END ########
#####################################

proc tmsh_create { component arguments } {
    regsub -all {\"} $arguments "\\\"" arguments
    regsub -all {\[} $arguments "\\\[" arguments
    regsub -all {\]} $arguments "\\\]" arguments
    tmsh::run_proc f5.app_utils:do_tmsh_create "\"$component\"" "\"$arguments\""
}

proc tmsh_modify { component arguments } {
    regsub -all {\"} $arguments "\\\"" arguments
    regsub -all {\[} $arguments "\\\[" arguments
    regsub -all {\]} $arguments "\\\]" arguments
    tmsh::run_proc f5.app_utils:do_tmsh_modify "\"$component\"" "\"$arguments\""
}

# Search on given vs for profile from given type
proc find_profile {vs_obj type sub_type} {
    set found false
    set fomated_type $type

    if { $type == "profile" } {set fomated_type "profiles"}

    catch {
        foreach {profile} [tmsh::get_config /ltm $type $sub_type] {
            foreach {vs_profile} [tmsh::get_field_value $vs_obj $fomated_type] {
                if {[lindex $vs_profile 1] == [lindex $profile 3]} {
                    set found true
                    return [lindex $vs_profile 1]
                }
            }
        }
    } result
    if { $found } {
        return $result
    }
    return ""
}

proc set_sse_vs {vs_obj} {
    set serverssl_profile $::advanced_features__serverssl
    if {$serverssl_profile != ""} {
        set sse_vs_port 443
        # Set dummy address for the ssl virtual server since the request route via iRule and it is internal usage only
        set sse_vs_dumy_addr $::advanced_features__vip2vip_ip
        set sse_vs_pool $::shape_sse_pool_name
        set snat_type "none"

        # Copy snat_type from original vs
        catch { set snat_type [tmsh::get_field_value $vs_obj source-address-translation.type] }

        # Copy http profile
        set http_profile [find_profile $vs_obj "profile" "http"]

        # Copy one-connect profile
        set oneconnect_profile [find_profile $vs_obj "profile" "one-connect"]
        if { $oneconnect_profile == "" } { set oneconnect_profile $::iapp_oneconnect }
        # create sse vs
        tmsh_create "/ ltm virtual" "${::shape_ssl_vs_name} {description \"Server Side SSL VS\" source 0.0.0.0/0 destination ${sse_vs_dumy_addr}:$sse_vs_port profiles replace-all-with { ${http_profile} ${oneconnect_profile} { context all } $serverssl_profile { context serverside } } pool $sse_vs_pool }"
        if { $::advanced_features__sni != "" } {
            tmsh::create ltm profile server-ssl $::sni_profile_name \{ defaults-from $serverssl_profile server-name $::advanced_features__sni \}
            tmsh::modify ltm virtual ${::shape_ssl_vs_name} profiles delete \{ $serverssl_profile \} profiles add \{ $::sni_profile_name \}
        }
        # Set default cookie persistence profile if selected
        if {$::pool__cookie_persistence == "Enable"} {tmsh_modify "/ ltm virtual" "${::shape_ssl_vs_name} persist replace-all-with { cookie }"}
        # 'snat' type requires snat pool so need to differentiate from other cases
        if {$snat_type != "snat"} {
            tmsh_modify "/ ltm virtual" "${::shape_ssl_vs_name} { source-address-translation { type $snat_type } }"
        } else {
            set snat_pool [tmsh::get_field_value $vs_obj source-address-translation.pool]
            tmsh_modify "/ ltm virtual" "${::shape_ssl_vs_name} { source-address-translation { type $snat_type pool $snat_pool } }"
        }
    }
}

proc detach_irule {vs_name} {
    if {$vs_name != ""} { tmsh_modify "/ltm virtual" "$vs_name rules none" }
}

proc supports_ssl {vs_obj profile_type} {
    set flag false
    catch {
        foreach {profile} [tmsh::get_field_value $vs_obj profiles] {
            if {[string first ${profile_type} $profile] != -1} {
                set flag true
            }
        }
    }
    return $flag
}

# Create HTML rule for JS injection. These rules will attached to the created HTL profile
proc create_injection_rule {snippet rule_name} {
    if {[get_tag_name $::js_injection__injection_location] == "script"} {
        # Append the rule to the HTML profile
        tmsh_modify "/ ltm profile" "html ${::shape_inject_html_profile_name} rules add { ${::html_before_script_rule} }"
        regsub __SNIPPET__ $::html_tag_matched_irule \{${snippet}\} ::html_tag_matched_irule
        regsub __HTML_TAG_MATCHED__ $::shape_sed_irule ${::html_tag_matched_irule} ::shape_sed_irule
    } else {
        regsub -all "\"" $snippet "\\\"" snippet
        tmsh::create ltm html-rule [get_tag_location $::js_injection__injection_location] ${rule_name} \{ action \{ text \"$snippet\" \} match \{ tag-name [get_tag_name $::js_injection__injection_location] \} \}
        regsub __HTML_TAG_MATCHED__ $::shape_sed_irule {} ::shape_sed_irule
        # Append the rule to the HTML profile
        tmsh_modify "/ ltm profile" "html ${::shape_inject_html_profile_name} rules add { ${rule_name} }"
    }
}

proc detach_html_rules {} {
    # html_profile does not exist until first deployment is completed
    set html_profiles [tmsh::get_config /ltm profile html]
    foreach {html_profile} $html_profiles {
        set html_profile_name [lindex $html_profile 3]
        catch { tmsh_modify "/ ltm profile" "html ${html_profile_name} rules delete { $::html_js_rule_name }" }
        catch { tmsh_modify "/ ltm profile" "html ${html_profile_name} rules delete { $::html_iojs_rule_name }" }
        catch { tmsh_modify "/ ltm profile" "html ${html_profile_name} rules delete { ${::html_before_script_rule} }" }
    }
}

proc config_shape_pool {} {
    # no effect if pool already exists
    tmsh_create "/ ltm pool" "${::shape_sse_pool_name}"
    # Make sure we have no members from prev configuration (in case pool already exists)
    tmsh_modify "/ ltm pool" "${::shape_sse_pool_name} members delete { all }"

    if {$::pool__sse_traffic_mode == "Active/Passive"} {
        puts "active/passive"
        tmsh_modify "/ ltm pool" "${::shape_sse_pool_name} min-active-members 1"
    } else {
        puts "active/active"
        tmsh_modify "/ ltm pool" "${::shape_sse_pool_name} min-active-members 0"
    }

    foreach member $::pool__pool_addresses {
        set ip [tmsh::get_field_value $member address]
        set pg 0

        if {$::pool__sse_traffic_mode == "Active/Passive"} {
            set pg [tmsh::get_field_value $member priority_group]
        }

        if { $ip matches_regex {(?=^.{4,253}$)(^((?!-)[a-zA-Z0-9-]{0,62}[a-zA-Z0-9]\.)+[a-zA-Z]{2,63}$)} } {
            tmsh_create "/ ltm node" "/Common/$ip fqdn { name $ip autopopulate enabled }"
            tmsh_modify "/ ltm pool" "${::shape_sse_pool_name} members add {/Common/$ip:443 {fqdn { autopopulate enabled } priority-group $pg}}"
        } else {
            if { $ip matches_regex {\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}} } {
                tmsh_modify "/ ltm pool" "${::shape_sse_pool_name} members add {/Common/$ip:443 {address $ip priority-group $pg}}"
            } else {
                tmsh_modify "/ ltm pool" "${::shape_sse_pool_name} members add {/Common/$ip.443 {priority-group $pg}}"
            }
        }
    }

    if { $::pool__check == "Yes" } {
        puts "create monitor $::shape_monitor { adaptive disabled defaults-from /Common/tcp destination *:$::pool__port interval 5 recv $::pool__rc recv-disable none send \"GET $::pool__url\ HTTP/1.0\r\nConnection: Close\r\n\r\n\" time-until-up 0 timeout 16 }"
        tmsh_create "/ ltm monitor tcp" "$::shape_monitor { adaptive disabled defaults-from /Common/tcp destination *:$::pool__port interval 5 recv $::pool__rc recv-disable none send \"GET $::pool__url\ HTTP/1.0\r\nConnection: Close\r\n\r\n\" time-until-up 0 timeout 16 }"
        tmsh_modify "/ ltm pool" "${::shape_sse_pool_name} monitor $::shape_monitor"
    } else {
        catch {
            tmsh_modify "/ ltm pool" "${::shape_sse_pool_name} monitor default"
        }
    }
}

proc init {} {
    # ---------- Internal Data Groups Names -----------------------
    set ::JS_DG "$::iapp_name\_ShapeJs"
    set ::SAFE_DG "$::iapp_name\_SafeEndpoint"

    # ---------- Shape Pool Configuration -------------------------
    set ::shape_monitor "$::iapp_name\_ShapeMonitor"
    set ::shape_sse_pool_name "$::iapp_name\_ShapeProdPool"
    # ---------- sse VS Configuration -----------------------------
    set ::shape_ssl_vs_name "$::iapp_name\_shape_ssl_vs"
    
    # Create HTML profile
    tmsh_create "/ ltm profile" "html ${::shape_inject_html_profile_name} { app-service none content-detection disabled content-selection add { text/html text/xhtml } defaults-from /Common/html description none }"
    tmsh_create "/ ltm html-rule" "tag-raise-event ${::html_before_script_rule} { match { tag-name script } }"

    # Create one-connect profile
    tmsh_create "/ ltm profile" "one-connect ${::iapp_oneconnect} source-mask 255.255.255.255"


    # Internal Data Group to hold the path of API call from JS
    set ::JS_API_DG "$::iapp_name\_SafeJsApiEp"
    tmsh_create "/ ltm data-group" "internal $::JS_API_DG { records replace-all-with { /v1.0/ {} } type string }"

}

proc detach_persist_profile {} {
    foreach {vs_obj} [tmsh::get_config /ltm virtual] {
        set vs_name [tmsh::get_name $vs_obj]
        regsub -all "/" ${vs_name} "_" format_vs_name
        set persist_vs_name "$::persist_cookie_name\_$format_vs_name"
        set cookie_persist [find_profile $vs_obj "persist" "cookie"]
        if { $cookie_persist == ${persist_vs_name} } {
            tmsh_modify "/ ltm virtual" "$vs_name persist none"
        }
    }
}

# Detach all iApp components before reconfigured
proc cleanup {} {
    foreach {vs} [tmsh::get_config /ltm virtual] {
        set vs_name [tmsh::get_name $vs]
        regsub -all "/" ${vs_name} "_" format_vs_name
        puts "========= $vs_name ==============="
        if {[lsearch -exact [tmsh::get_field_names value $vs] "rules"] < 0} {
            puts "No attached iRules for $vs_name"
            continue
        }
        set rules_list [tmsh::get_field_value $vs rules]
        set formated_rule_name "$::sse_irule_name\_${format_vs_name}"
        puts "formated_rule_name: $formated_rule_name"
        set idx [lsearch -exact $rules_list $formated_rule_name]
        if {$idx >= 0} {
            set rules_list [lreplace $rules_list $idx $idx]
            detach_irule $vs_name
        }
        tmsh_modify "/ ltm virtual" "$vs_name rules { $rules_list }"

        ## detach the HTML and oneconnect profiles from the VS
        catch { tmsh_modify "/ ltm virtual" "$vs_name profiles delete { $::shape_inject_html_profile_name }" }
        catch { tmsh_modify "/ ltm virtual" "$vs_name profiles delete { $::iapp_oneconnect }" }
    }
    detach_html_rules
    detach_persist_profile
    catch {
        tmsh::delete ltm profile html profile ${::shape_inject_html_profile_name}
    }
}

proc config_js_injection {} {
    detach_html_rules
    set injection_url [string tolower "$::js_injection__injection_path"]
    if { $::js_injection__inject_tags == "Yes" && $injection_url != ""} {
        
        set inject_type [string tolower $::js_injection__script_attribute]
        set ::js_snippet "<script id=\"_imp_sdk_\" type=\"text/javascript\" src=\"$injection_url\" $inject_type ></script>"
        create_injection_rule $::js_snippet $::html_js_rule_name
        if {[get_tag_name $::js_injection__injection_location] == "body"} {
            tmsh_create "/ ltm html-rule" "tag-append-html ${::html_js_rule_name} { action { text \"$::js_snippet\" } match { tag-name body } }"
            # Append the rule to the HTML profile
            tmsh_modify "/ ltm profile" "html ${::shape_inject_html_profile_name} rules add { ${::html_js_rule_name} }"
        }
        
    } 
    if { $injection_url != "" } {
        if { [string first / $injection_url] != 0 } {
            regsub "^https?:\/\/" $injection_url "" injection_url
            puts "got absolute JS path and remove protocol: $injection_url"
            regsub __JS_PATH__ $::shape_sed_irule {[HTTP::host][HTTP::path -normalized]} ::shape_sed_irule
        } else {
            puts "got relative JS path: $injection_url"
            regsub __JS_PATH__ $::shape_sed_irule {[HTTP::path -normalized]} ::shape_sed_irule
        }
        # Insert the JS path to the Data Group
        tmsh_create "/ ltm data-group" "internal $::JS_DG { records replace-all-with { $injection_url { } } type string }"
        if { $::js_injection__inject_tags == "No" } {
            regsub __HTML_TAG_MATCHED__ $::shape_sed_irule {} ::shape_sed_irule
        }
    } else {
        regsub __JS_PATH__ $::shape_sed_irule {[HTTP::path -normalized]} ::shape_sed_irule
    }
}
proc collect_endpoints {protected_endpoints_tbl isIappMitigation} {
    foreach member $protected_endpoints_tbl {
        set endpoint [string tolower [tmsh::get_field_value $member endpoint]]
        if { $endpoint == "" } { continue }
        # trim the trailing slash if exist
        set endpoint [string trimright ${endpoint} "/"]
        set mitigation ""
        set record_value ""
        regsub -all {\*} $endpoint {\\\*} endpoint
        append SAFE_EP_members "$endpoint {}"
    }
    if { [info exists SAFE_EP_members] && [string length ${SAFE_EP_members}] > 0 } {tmsh_create "/ ltm data-group" "internal $::SAFE_DG records add { ${SAFE_EP_members}} type string" }
}

proc config {} {
    # Init the template
    init

    set INCLUDED_ENTRY_POINT_DG "$::iapp_name\_includedEntryPoints"
    set EXCLUDED_ENTRY_POINT_DG "$::iapp_name\_excludedEntryPoints"
    regsub __DEBUG__ $::shape_sed_irule [iapp::is ::advanced_features__debug Yes] ::shape_sed_irule


    # Set safe domain
    regsub __SAFE_DOMAIN__ $::shape_sed_irule "imp.zeronaught.com" ::shape_sed_irule

    # Collect additional JS API Endpoints if needed
    if {$::js_injection__add_additional_jsApi_ep == "Yes"} {
        foreach ep $::js_injection__jsApi_table {
            append additional_jsApi_ep "[tmsh::get_field_value $ep js_api_ep] "
        }

        if { [info exists additional_jsApi_ep] && [string length $additional_jsApi_ep] > 1} {
            tmsh_create "/ ltm data-group" "internal $::JS_API_DG { records add { ${additional_jsApi_ep}} type string }"
        }
    }




    # Collect the required safe endpoints members
    collect_endpoints $::cookie__endpoints 0

    # config shape pool
    config_shape_pool

    regsub __JS_DG__ $::shape_sed_irule $::JS_DG ::shape_sed_irule
    regsub __INCLUDED_ENTRY_POINTS_DG__ $::shape_sed_irule $INCLUDED_ENTRY_POINT_DG ::shape_sed_irule
    regsub __EXCLUDED_ENTRY_POINTS_DG__ $::shape_sed_irule $EXCLUDED_ENTRY_POINT_DG ::shape_sed_irule
    regsub __SHAPE_SSE_POOL__ $::shape_sed_irule $::shape_sse_pool_name ::shape_sed_irule
    regsub __KILL_SWITCH__ $::shape_sed_irule [iapp::is ::general__kill_switch Yes] ::shape_sed_irule
    regsub __SAFE_EP_DG__ $::shape_sed_irule $::SAFE_DG ::shape_sed_irule
    if { $::cookie__enc_key matches_regex {^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$} } {
        regsub __ENC_KEY__ $::shape_sed_irule $::cookie__enc_key ::shape_sed_irule
    } else {
        regsub __ENC_KEY__ $::shape_sed_irule 0 ::shape_sed_irule
        puts "Encryption key is not valid"
    }
    regsub __COOKIE_NAME__ $::shape_sed_irule $::cookie__name ::shape_sed_irule
    regsub __FR_HEADER__ $::shape_sed_irule $::cookie__header_name ::shape_sed_irule
    regsub __API_JS_DG__ $::shape_sed_irule $::JS_API_DG ::shape_sed_irule


    set specific_flag 0
    set excluded_flag 0


    # The user specific web pages (entry pages) for injection
    if {$::js_injection__inject_tags == "Yes"} {
        if {$::js_injection__inject_by_endpoint == "Yes"} {
            # Collect the injected entry points
            set included_entry_pages ""
            foreach path $::js_injection__injected_ep {
                set endpoint [string trimright [tmsh::get_field_value $path end_point] "/"]
                if { $endpoint != "" } {
                    append included_entry_pages "$endpoint "
                }
            }
            if { $included_entry_pages != "" } {
                regsub -all {\*} $included_entry_pages {\\\*} included_entry_pages
                tmsh_create "/ ltm data-group" "internal $INCLUDED_ENTRY_POINT_DG records replace-all-with { $included_entry_pages} type string"
                set specific_flag 1
            }
        }
        if {$::js_injection__exclude_endpoint == "Yes"} {
            # Collect the excluded entry points
            set excluded_entry_pages ""
            foreach path $::js_injection__excluded_ep {
                set endpoint [string trimright [tmsh::get_field_value $path end_point] "/"]
                if { $endpoint != "" } {
                   append excluded_entry_pages "$endpoint "
                }
            }
            if { $excluded_entry_pages != "" } {
                regsub -all {\*} $excluded_entry_pages {\\\*} excluded_entry_pages
                tmsh_create "/ ltm data-group" "internal $EXCLUDED_ENTRY_POINT_DG records replace-all-with { $excluded_entry_pages} type string"
                set excluded_flag 1
            }
        }
    }
    regsub __JS_EXCLUDED_PATH__ $::shape_sed_irule $excluded_flag ::shape_sed_irule
    regsub __JS_SPECIFIC_PATH__ $::shape_sed_irule $specific_flag ::shape_sed_irule

    # Inject XFF flag into irule
    regsub __XFF__ $::shape_sed_irule [iapp::is ::advanced_features__xff Yes] ::shape_sed_irule

    # Inject __USE_DIFFERENT_SSL__ flag into irule
    regsub __SHAPE_SSL_VS_NAME__ $::shape_sed_irule ${::shape_ssl_vs_name} ::shape_sed_irule
    if { $::advanced_features__serverssl != ""} { regsub __USE_DIFFERENT_SSL__ $::shape_sed_irule true ::shape_sed_irule } 
    else { regsub __USE_DIFFERENT_SSL__ $::shape_sed_irule false ::shape_sed_irule }

    foreach vs ${::vs_config__vs} {
        puts "======= vs: $vs ========"
        set vs_name ""
        set vs_irule ""
        set customer_irules ""

        # Replace '/' with '_' in order to name the iRule based on Virtual Server
        regsub -all "/" $vs "_" vs_name
        set vs_irule_name "$::sse_irule_name\_${vs_name}"
        set persist_vs_name "$::persist_cookie_name\_$vs_name"
        tmsh_create "/ ltm persistence" "cookie ${persist_vs_name}"
        # Get the pool name for selected Virtual Server
        set vs_obj [lindex [tmsh::get_config /ltm virtual ${vs}] 0]
        # If customer has irules configured, we want to backup them for later
        catch {
            foreach {rule} [tmsh::get_field_value $vs_obj rules] {
                lappend customer_irules $rule
            }
        }
        # If customer using https, then we can use "SSL::disable serverside". Otherwise we don't use it
        if { [supports_ssl $vs_obj "serverssl"] } { regsub -all __DISABLE_SSL__ $::shape_sed_irule "SSL::disable serverside" ::shape_sed_irule }
        else {  regsub -all __DISABLE_SSL__ $::shape_sed_irule "" ::shape_sed_irule }

        if { [supports_ssl $vs_obj "clientssl"] } { regsub -all __PROTO__ $::shape_sed_irule "https" ::shape_sed_irule } 
        else {  regsub -all __PROTO__ $::shape_sed_irule "http" ::shape_sed_irule }

        # Add HTML profile if not exist
        set html_profile [find_profile $vs_obj "profile" "html"]
        if { $html_profile == "" } {
            set no_profile true
            set html_profile ${::shape_inject_html_profile_name}
        } else {
            set profile_obj [lindex [tmsh::get_config /ltm profile html ${html_profile}] 0]
            catch { 
                set html_rules [tmsh::get_field_value $profile_obj rules]
                tmsh_modify "/ ltm profile" "html ${::shape_inject_html_profile_name} rules add { $html_rules }"
            }
        }

        config_js_injection

        # Check if VS has oneconnect profile, if no we add default one.
        set oneconnect_profile [find_profile $vs_obj "profile" "one-connect"]
        if { $oneconnect_profile == ""} { set oneconnect_profile $::iapp_oneconnect }

        ## Handle Cookie Persistence
        set cookie_persist [find_profile $vs_obj "persist" "cookie"]
        if {$::pool__cookie_persistence == "Enable"} {
            if {$::advanced_features__serverssl == ""}  {
                # Customer enabled shape cookie persistence and persist cookie not attached to VS --> attached default cookie persistence
                regsub __SHAPE_COOKIE_PERSIST__ $::shape_sed_irule "persist cookie insert \"$tmsh::app_name\_persist_cookie\"" ::shape_sed_irule
                if {$cookie_persist == "" || $cookie_persist == ${persist_vs_name}} {
                    tmsh_modify "/ ltm virtual" "${vs} persist replace-all-with { ${persist_vs_name} }"
                    # Disable cookie persistence for customer 
                    regsub __APP_PERSIST_NONE__ $::shape_sed_irule {persist none} ::shape_sed_irule
                } else {
                    # Cookie persistence attached to VS and costumer enable shape cookie persistence
                    regsub __APP_PERSIST_NONE__ $::shape_sed_irule {} ::shape_sed_irule
                }
            } else {
                # The iApp will created different VS for shape traffic (since different SSL profile selected)
                # --> since the traffic route from the VS, it will handle the cookie persistence and no need for iRule handeling
                # The cookie persistence profile will create from set_sse_vs proc
                regsub __APP_PERSIST_NONE__ $::shape_sed_irule {} ::shape_sed_irule
                regsub __SHAPE_COOKIE_PERSIST__ $::shape_sed_irule {} ::shape_sed_irule

                # The user select different SSL profile so the request will route to ssl_vs --> it will handle the persistence 
                if { $cookie_persist == ${persist_vs_name} } {
                    tmsh_modify "/ ltm virtual" "${vs} persist none"
                }
            }
        } else {
            # Cookie persistence for Shape pool disabled
            regsub __APP_PERSIST_NONE__ $::shape_sed_irule {} ::shape_sed_irule
            if {$::advanced_features__serverssl == "" && $cookie_persist != ""}  {
                # Customer disable the persistence for Shape but set persistence to the application
                # In that case we need to allow persistence for application but disable it for shape pool
                regsub __SHAPE_COOKIE_PERSIST__ $::shape_sed_irule {persist none} ::shape_sed_irule
            } else {
                # The iApp creates new VS, so no need for persistence handling on iRule
                regsub __SHAPE_COOKIE_PERSIST__ $::shape_sed_irule {} ::shape_sed_irule
            }

            # The founded persistence profile set by the iApp --> Remove it while the user disable the profile
            if { $cookie_persist == ${persist_vs_name} } {
                tmsh_modify "/ ltm virtual" "${vs} persist none"
            }
        }

        regsub -all "\\\\" $::shape_sed_irule "\\\\\\\\" vs_irule
        regsub -all {\$} $::shape_sed_irule "\\\\$" vs_irule
        # Set the iRule content


        tmsh_create "/ ltm rule" "${vs_irule_name} \{ $vs_irule \}"

        lappend customer_irules ${vs_irule_name}

        tmsh_modify "/ ltm virtual" "${vs} { profiles delete { ${html_profile} } profiles add { ${oneconnect_profile} ${::shape_inject_html_profile_name} } rules { ${customer_irules} } }"

        # Create vs for bigip <-> SSE in case client has chose to use another sslprofile between them.
        set_sse_vs $vs_obj
    }
}

#*************
#***** Return the tag location, after or before tag. (0-> after, 1-> before)
#*************
proc get_tag_location {tag} {
    switch -- $tag {
        "After <head>" { return "tag-append-html"}
        "After </title>" { return "tag-append-html" }
        "After <body>" { return "tag-append-html" }
        "Before <script>" { return "tag-prepend-html" }
    }
    # Default is after tag
    return "tag-append-html"
}

#*************
#***** Return the tag tag name
#*************
proc get_tag_name {tag} {
    puts "received tag: $tag"
    switch -- $tag {
        "After <head>" { return "head" }
        "After </title>" { return "/title" }
        "After <body>" { return "body" }
        "Before <script>" { return "script" }
    }
    return $tag
}


#*************
#***** Main routine
#*************
cleanup
if { $::general__clean == "Yes" } {
    return
}

config

}
    			macro {}
    			presentation{
define choice yesno display "small" default "No" {"Yes", "No"}
define choice enable_disable display "medium" default "Disable" {"Enable", "Disable"}
define choice response_code default "200" display "small" {"200", "201", "202", "204", "303", "304", "307", "400", "401", "403", "404", "405", "406", "412", "415", "500", "501"}
section topic {
    message introduction "Configure the BIG-IP to work with SAFE solution. For detailed information and configuration, see the deployment guide https://github.com/F5Networks/shape-iapp/blob/safe-v1.0.0/SAFE/Deploy%20SAFE%20iApp%20Template%20in%20BIG-IP%2C%20v1.0.0.pdf"
    message updates "Check for new versions of this template on the F5 Official iApp Github repository: https://github.com/F5Networks/shape-iapp/releases"
    message version "v1.0.0"
}

section general {
    yesno clean
    optional (clean == "No") {
        yesno kill_switch
    }
}

optional (general.clean == "No") {
    section js_injection {
        choice inject_tags default "Yes" {"Yes", "No"}
        string injection_path display "xlarge"
        message injection_path_msg "The JS injection path can be set either relative or absolute. A relative path must start with a slash '/’."
        optional (inject_tags == "Yes") {
            choice injection_location default "After <head>" {"After <head>", "After <body>"}
        }
        choice script_attribute default "Async" {"Async", "Sync", "Defer"}
        optional (inject_tags == "Yes") {
            yesno inject_by_endpoint
            optional (inject_by_endpoint == "Yes") {
                table injected_ep {
                    string end_point required display "large"
                }
            }

            yesno exclude_endpoint
            optional (exclude_endpoint == "Yes") {
                table excluded_ep {
                    string end_point required display "large"
                }
            }
        }

        optional (inject_tags == "No") {
            message snippets_note "Since you did not select the BIG-IP to handle JS injections, you need to put the following snippet(s) in the code of your web application. Replace ‘INJECTION_PATH’ with the path you received from F5 support."
            optional (script_attribute == "Async") {
                message js_snippet_async_msg "<script id='_imp_sdk_' type='text/javascript' src='INJECTION_PATH' async></script>"
            }
            optional (script_attribute == "Sync") {
                message js_snippet_sync_msg "<script id='_imp_sdk_' type='text/javascript' src='INJECTION_PATH' sync></script>"
            }
            optional (script_attribute == "Defer") {
                message js_snippet_defer_msg "<script id='_imp_sdk_' type='text/javascript' src='INJECTION_PATH' defer></script>"
            }
        }

        message js_api_msg "The default JS API endpoints are: '/v1.0/*'. You can add additional endpoints below."
        yesno add_additional_jsApi_ep
        optional (add_additional_jsApi_ep == "Yes") {
            table jsApi_table {
                string js_api_ep required display "large"
            }
        }
    }

    section cookie {
        table endpoints {
            string endpoint display "large"
        }
        message note "The endpoint path must start with ‘/’."
        message lc_note "Endpoints are not case sensitive. Regardless of whether you use upper or lower case letters, all letters are set to lower case."

        string name display "medium"
        string enc_key display "medium"
        string header_name display "medium" default "x-safe-fr"
    }

    section pool {
        choice sse_traffic_mode default "Active/Active" {"Active/Active", "Active/Passive"}
        enable_disable cookie_persistence
        table pool_addresses {
            string address required validator "IpOrFqdn" display "large"
            optional (sse_traffic_mode == "Active/Passive") {
                string priority_group required validator "NonNegativeNumber" display "small"
            }
        }
        yesno check
        optional (check == "Yes") {
        string url required display "large"
        string port required display "small" validator "PortNumber"
        string rc required display "small" validator "NonNegativeNumber"
        }
    }
    section vs_config {
        message note "Your virtual server must have an HTTP profile and default pool attached to it."
        multichoice vs display "xlarge" tcl {
                package require iapp 1.3.0
                set ::choices "[iapp::get_items ltm virtual]"
                return [iapp::safe_display ::choices]
            }
    }

    section advanced_features {
        choice xff default "Yes" display "small" {"Yes", "No"}
        message note "HTTP profile has the ability to insert XFF value. make sure you do not enable both."
        multichoice serverssl display "xlarge" default {"/Common/serverssl"} tcl {
            package require iapp 1.3.0
            set ::choices "[iapp::get_items ltm profile server-ssl]"
            return [iapp::safe_display ::choices]
        }
        string vip2vip_ip display "medium" validator "IpOrFqdn" default "1.2.3.4" required
        string sni display "large" validator "FQDN"
        yesno debug
    }
}

text {
    topic "Welcome to the iApp template for SAFE"
    topic.introduction "Introduction"
    topic.updates "Check for Updates"
    topic.version "Template Version:"

    # **** General ****
    general "General"
    general.clean "Clean Before Deletion"
    general.kill_switch "Activate Kill-Switch"

    # *******
    # ** JavaScript Injection
    # *******
    js_injection "JS Injection Configuration"
    js_injection.injection_path "Shape JS URL or Path"
    js_injection.injection_path_msg "Note"
    js_injection.injection_location "Location for Shape JS Injection"
    js_injection.inject_by_endpoint "Inject Shape JS in Specific Webpages Only"
    js_injection.injected_ep "JS Injection Paths"
    js_injection.injected_ep.end_point "Path"
    js_injection.exclude_endpoint "Exclude Shape JS Injection from Specific Webpages"
    js_injection.excluded_ep "JS Excluded Paths"
    js_injection.excluded_ep.end_point "Path"
    js_injection.js_api_msg "Note"
    js_injection.add_additional_jsApi_ep "Add Additional JS API Endpoints"
    js_injection.jsApi_table "JS API Endpoints"
    js_injection.jsApi_table.js_api_ep "Endpoint"
    js_injection.script_attribute "Script Attribute"
    js_injection.js_snippet_async_msg "JS Snippet"
    js_injection.js_snippet_sync_msg "JS Snippet"
    js_injection.js_snippet_defer_msg "JS Snippet"
    js_injection.inject_tags "BIG-IP Handles JS Injections"
    js_injection.snippets_note "Note"
    # ===========================================================
    # =============== pool configuration section ================
    # ===========================================================
    pool "Pool Configuration"


    pool.pool_addresses "Shape Protection Pool"
    pool.pool_addresses.address "Pool Member (either IP or FQDN)"
    pool.cookie_persistence "Cookie Persistence for Shape Protection Pool"
    pool.check "Add HTTP Health Check"
    pool.url "Liveness Path"
    pool.port "Port"
    pool.rc "Response Code"
    pool.sse_traffic_mode "Traffic Routing Methodology"
    pool.pool_addresses.priority_group "Priority Group"
    # ===========================================================
    # =============== vs config Section =======================
    # ===========================================================
    vs_config "Virtual Server Configuration"
    vs_config.note "Note"
    vs_config.vs "Application’s Virtual Server(s) to Protect"

    # ===========================================================
    # =============== Advanced Features Section =================
    # ===========================================================
    advanced_features "Advanced Features"
    advanced_features.xff "Rewrite XFF Header with Connecting IP"
    advanced_features.note "Note"
    advanced_features.serverssl "Choose a Parent Server-Side SSL Profile for Shape Pool"
    advanced_features.sni "Server Name"
    advanced_features.vip2vip_ip "Encrypting Virtual Server IP"
    advanced_features.debug "Enable Debug"

    # ===========================================================
    # =============== Cookie Decryption and Processing ==========
    # ===========================================================
    cookie "Cookie Decryption and Processing"
    cookie.endpoints "Endpoints"
    cookie.endpoints.endpoint "Path"
    cookie.name "Cookie Name"
    cookie.enc_key "Encryption Key (Base64 encoded)"
    cookie.header_name "Header Name to Add"
    cookie.note "Note"
    cookie.lc_note ""
}
}
    			role-acl none
    			run-as none
    		}
    	}
    	description none
    	ignore-verification false
    	requires-bigip-version-max none
    	requires-bigip-version-min 12.1.0
    	requires-modules { ltm }
    	signing-key none
    	tmpl-checksum none
    	tmpl-signature none
    }